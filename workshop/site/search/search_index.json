{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Docker Workshop","text":""},{"location":"#github-sources","title":"GitHub Sources","text":"<p>The source code for this workshop is available here</p>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Ajeet Singh Raina - DevRel @Docker</li> </ul>"},{"location":"#benefits-of-this-docker-workshop","title":"Benefits of this Docker Workshop","text":"<ul> <li>Learn about Inner-loop development workflow</li> <li>Learn about Docker Developer workflow</li> <li>Learn about Docker Init</li> <li>Learn about Compose Watch</li> <li>Learn how to containerise a Todo-List application</li> </ul>"},{"location":"lab1/best-practices/","title":"Image Best Practices","text":""},{"location":"lab1/compose-watch/","title":"Overview of Compose Watch","text":""},{"location":"lab1/compose-watch/#compose-watch","title":"Compose Watch","text":""},{"location":"lab1/docker-init/","title":"Introduction to Docker init","text":""},{"location":"lab1/docker-init/#introducing-docker-init","title":"Introducing Docker Init","text":"<p>Introduced for the first time in Docker Desktop 4.18, the new docker init CLI generates Docker assets for projects, making it easier to create Docker images and containers. When you run the docker init command in your project directory, it will guide you through the creation of the necessary files for your project with sensible defaults. These files include:</p> <pre><code>.dockerignore\nDockerfile\ndocker-compose.yaml\n</code></pre> <p>The docker init command also allows you to choose the application platform that your project uses and the relative directory of your main package. </p>"},{"location":"lab1/docker-init/#whos-this-for","title":"Who\u2019s this for?","text":"<p>This feature is targeted at developers who want to quickly create and manage Docker assets without having to manually configure everything. </p>"},{"location":"lab1/docker-init/#benefits-of-docker-init","title":"Benefits of Docker Init","text":"<p>The advantages of using the docker init command include:</p> <ul> <li>Simplified Docker asset creation: The command streamlines the creation of necessary Docker files, reducing the chances of errors and ensuring that best practices are followed.</li> <li>Saves time and effort: With the default settings and guided prompts, users can quickly create Docker assets without the need for extensive knowledge of Docker or its syntax.</li> <li>Better project organization: The generated files provide a standardized and organized structure for the project, making it easier for developers to maintain and update the project over time.</li> <li>Enhanced portability: By using Docker assets, projects become more portable across different environments, making it easier to move the project from development to production.</li> </ul> <p></p>"},{"location":"lab1/docker-init/#getting-started","title":"Getting Started","text":""},{"location":"lab1/docker-init/#clone-the-repository","title":"Clone the repository","text":"<pre><code>git clone https://github.com/dockersamples/docker-init-demos\ncd docker-init-demos/node\n</code></pre>"},{"location":"lab1/docker-init/#run-the-following-command","title":"Run the following command:","text":"<pre><code> docker init\n</code></pre> <p>This utility will walk you through creating the following files with sensible defaults for your project:   - .dockerignore   - Dockerfile   - docker-compose.yaml</p>"},{"location":"lab1/docker-init/#install-the-dependencies","title":"Install the Dependencies","text":"<pre><code>npm install\n</code></pre>"},{"location":"lab1/docker-init/#running-the-container-service","title":"Running the container service","text":"<pre><code> docker compose up -d --build\n</code></pre>"},{"location":"lab1/docker-init/#accessing-the-node-app","title":"Accessing the Node app","text":"<pre><code> curl localhost:8080      .\n/\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\\___/ ===\n{                       /  ===-\n\\______ O           __/\n \\    \\         __/\n  \\____\\_______/\n\n\nHello from Docker\n</code></pre>"},{"location":"lab1/docker-workflow/","title":"Docker Developer workflow","text":""},{"location":"lab1/overview/","title":"Introduction to Inner Loop Development workflow","text":""},{"location":"lab2/aws-s3-setup/","title":"Configuring AWS with IAM and S3","text":""},{"location":"lab2/aws-s3-setup/#1-login-to-aws-and-create-a-user","title":"1. Login to AWS and create a user","text":""},{"location":"lab2/aws-s3-setup/#2-add-a-user-called-developer","title":"2. Add a user called developer","text":""},{"location":"lab2/aws-s3-setup/#3-creat-a-group","title":"3. Creat a group","text":""},{"location":"lab2/aws-s3-setup/#4-add-developer-to-admin1-group","title":"4. Add developer to admin1 group","text":""},{"location":"lab2/aws-s3-setup/#5-review-and-save","title":"5. Review and save","text":""},{"location":"lab2/aws-s3-setup/#6-enable-access-keys-and-security-key-for-this-user","title":"6. Enable Access Keys and Security key for this user","text":""},{"location":"lab2/aws-s3-setup/#7-create-a-s3-bucket","title":"7. Create a S3 bucket","text":""},{"location":"lab2/aws-s3-setup/#8-grant-this-user-with-s3-bucket-access","title":"8. Grant this user with S3 bucket access","text":""},{"location":"lab2/overview/","title":"Overview","text":"<p>Container-first development takes the concept of containerization a step further. It involves using containers for every aspect of software development, including the application runtime itself. This means developers can ditch traditional local installations and leverage containers for everything needed to run the application.</p>"},{"location":"lab2/overview/#what-it-means","title":"What it means?","text":"<p>In container-first development, developers work within a containerized environment. They:</p> <ul> <li>Clone the project repository.</li> <li>Run a command (often docker-compose up or docker-compose watch) to start the development environment. This command usually pulls pre-built container images containing the application runtime (e.g., Node.js, Python interpreter) and any dependencies.</li> </ul> <p>That's it! The development environment is up and running entirely within containers. No need to install the application runtime or specific libraries on the developer's machine.</p>"},{"location":"lab2/overview/#benefits-for-developers","title":"Benefits for Developers:","text":"<ul> <li>Extreme Portability: Developers only need a container engine and an IDE to work on the project. This ensures identical development environments regardless of the underlying operating system or pre-installed software.</li> <li>Faster Setup: No time wasted installing the application runtime or fiddling with local configurations. Developers can start coding as soon as the containerized environment is up.</li> <li>Improved Isolation: Each project runs within its own isolated container, preventing conflicts between projects or dependencies from interfering with other applications on the developer's machine.</li> <li>Simplified Collaboration: Team members can easily share and reproduce development environments using the same container images.</li> </ul>"},{"location":"lab2/overview/#choosing-container-first","title":"Choosing Container-First:","text":"<ul> <li>Container-first development is ideal for teams seeking:</li> <li>Maximum portability across development environments.</li> <li>Fast and streamlined development setup.</li> <li>Strong isolation between projects to avoid conflicts.</li> </ul> <p>However, it requires a steeper learning curve for containerization technologies and might have higher resource demands.</p> <p>Container-first development offers a powerful approach for building applications entirely within containerized environments. It streamlines development workflows, ensures consistent development environments, and promotes collaboration. But, it's important to weigh the benefits against the increased complexity and potential resource usage before adopting this approach for your development team.</p>"},{"location":"lab2/services/","title":"Bringing up the services","text":""},{"location":"lab2/services/#1-clone-the-repository","title":"1. Clone the repository:","text":"<pre><code>git clone https://github.com/dockersamples/getting-started-todo-app\ncd getting-started-todo-app\n</code></pre>"},{"location":"lab2/services/#2-switch-to-container-first-branch","title":"2. Switch to container-first branch","text":"<pre><code>git checkout container-first\n</code></pre>"},{"location":"lab2/services/#3-add-the-environment-variables","title":"3. Add the Environment Variables","text":"<p>Ensure that you have the right environmental variable added to your Docker Compose file</p> <pre><code>   environment:\n      - MONGODB_URI=mongodb://mongodb:27017/todo-app\n      - JWT_SECRET=603b31XXXXXXX90d3b8cb62f0a585fd70a5ee0b4d\n      - AWS_ACCESS_KEY_ID=AKIAXXXXXDDDX\n      - AWS_SECRET_ACCESS_KEY=hSYXtvXXXXXXXO/k39FGt3u078pYWsh\n      - AWS_REGION=us-east-1\n      - S3_BUCKET_NAME=localbuckett\n   networks:\n      - localnet\n</code></pre> <p>You can leverage this link to generate JWT token.</p>"},{"location":"lab2/services/#4-bring-up-the-services","title":"4. Bring up the services:","text":"<pre><code>docker compose up -d\n</code></pre>"},{"location":"lab2/services/#5-access-the-app","title":"5. Access the app","text":"<p>Open http://localhost:3000 to access the todo-list app. Try adding a task and uploading the image.</p>"},{"location":"lab2/services/#verify-mongo","title":"Verify Mongo","text":"<p>You can verify if task gets added by selecting the container and clicking on \"Exec\" option on the Docker dashboard. Now you should be able to run the following command to verify the tasks.</p> <pre><code># mongosh\nCurrent Mongosh Log ID: 66879e864955d6e7b2f3f54d\nConnecting to:          mongodb://127.0.0.1:27017/?directConnection=true&amp;serverSelectionTimeoutMS=2000&amp;appName=mongosh+2.2.10\nUsing MongoDB:          7.0.12\nUsing Mongosh:          2.2.10\n\nFor mongosh info see: https://docs.mongodb.com/mongodb-shell/\n\n\nTo help improve our products, anonymous usage data is collected and sent to MongoDB periodically (https://www.mongodb.com/legal/privacy-policy).\nYou can opt-out by running the disableTelemetry() command.\n\n------\n   The server generated these startup warnings when booting\n   2024-07-05T07:18:03.008+00:00: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine. See http://dochub.mongodb.org/core/prodnotes-filesystem\n   2024-07-05T07:18:03.737+00:00: Access control is not enabled for the database. Read and write access to data and configuration is unrestricted\n   2024-07-05T07:18:03.738+00:00: /sys/kernel/mm/transparent_hugepage/enabled is 'always'. We suggest setting it to 'never' in this binary version\n   2024-07-05T07:18:03.738+00:00: vm.max_map_count is too low\n------\n\ntest&gt; show dbs\nadmin     40.00 KiB\nconfig    12.00 KiB\nlocal     40.00 KiB\ntodo-app  68.00 KiB\ntest&gt; use todo-app\nswitched to db todo-app\ntodo-app&gt; show collections\ntodos\nusers\ntodo-app&gt; db.todos.showDocuments()\nTypeError: db.todos.showDocuments is not a function\ntodo-app&gt; db.todos.countDocuments()\n1\ntodo-app&gt; db.todos.countDocuments()\n2\ntodo-app&gt; db.todos.countDocuments()\n3\ntodo-app&gt;\n</code></pre>"},{"location":"lab2/services/#verify-the-images-added-to-aws-s3","title":"Verify the images added to AWS S3","text":"<p>Open AWS Dashboard &gt; S3 service to see the list of images uploaded.</p> <p></p>"},{"location":"lab2/tech-stack/","title":"Tech stack","text":"<ul> <li>Frontend: React, Material UI.</li> <li>Backend: Node.js, Express</li> <li>Database: Mongo(Atlas or running locally for storing tasks)</li> <li>Object Storage: AWS S3(for storing images)</li> </ul>"},{"location":"lab3/overview/","title":"Overview","text":"<p>Container-supported development is the idea of using containers to support and enhance development without touching the main application runtime itself. </p>"},{"location":"lab3/overview/#what-it-means","title":"What it means?","text":"<p>The developer will run their application using a runtime installed natively on their machine (such as a JVM, Node engine, or Python interpreter). But, the external dependencies will run in containers. </p>"},{"location":"lab3/overview/#what-benefits-does-it-provide-to-the-developers","title":"What benefits does it provide to the developers?","text":"<p>Even though the developers didn\u2019t go \u201call-in\u201d, Docker still provided significant value by running dependent services out of containers, making it quick and easy to get started and ensure version consistency across the entire team.</p> <p>With Docker, teams can do things that might otherwise have been impossible. They can run local instances of cloud services, run real services in their tests, and more. There is no \u201cone right path\u201d for teams to leverage Docker. You see teams using wrapper scripts that run docker run commands, others using IDE plugins to launch declarative Compose stacks, or programmatic interactions using Testcontainers.In many of these cases, teams can leverage off-the-shelf (or very slightly customized versions of) images from our DOI/DVP catalog.</p>"},{"location":"lab3/overview/#choosing-the-container-supported-approach","title":"Choosing the container-supported approach:","text":"<ul> <li> <p>Separation of Concerns: Developers focus on the core application logic using their familiar runtime (JVM, Node, Python etc.), while external dependencies are isolated in containers.</p> </li> <li> <p>Improved Efficiency:</p> </li> <li> <p>Easier setup: Containers simplify dependency management, reducing time spent configuring environments. Version consistency: All developers use the same container image, ensuring consistent dependencies across the team.</p> </li> <li> <p>Enhanced Capabilities: Docker allows running local simulations of cloud services and real services within tests, providing a more realistic development environment.</p> </li> <li> <p>Flexibility in Implementation: There's no single approach. Teams can use:</p> </li> <li> <p>Wrapper scripts for simple container execution.</p> </li> <li>IDE plugins for launching development environments defined in Docker Compose files.</li> <li> <p>Programming interactions with libraries like Testcontainers.</p> </li> <li> <p>Leveraging Shared Resources: Teams can benefit from pre-built container images from public repositories like Docker Official Images (DOI) and Docker Verified Publishers (DVP).</p> </li> </ul> <p>Overall, container-supported development offers a way to streamline the development process by managing dependencies and enhancing development environments without completely switching to a containerized application runtime.</p>"},{"location":"prereq/prereq/","title":"Prerequisites","text":""},{"location":"prereq/prereq/#1-docker-desktop","title":"1. Docker Desktop","text":"<p>Download and Install Docker Desktop on your system. Make sure you are using Docker Desktop v4.27.2 and above.</p> <ul> <li>Apple Chip</li> <li>Intel Chip</li> <li>Windows</li> <li>Linux</li> </ul>"},{"location":"prereq/prereq/#enabling-wsl-2-based-engine-on-docker-desktop-for-windows","title":"Enabling WSL 2 based engine on Docker Desktop for Windows","text":"<p>In case you're using Windows 11, you will need to enable WSL 2 by opening Docker Desktop &gt; Settings &gt; Resources &gt; WSL Integration</p> <p></p>"}]}